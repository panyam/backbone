// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package teams

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type TeamService interface {
	// Removes all entries.
	RemoveAllTeams() (err error)
	// Create or update a team.
	// If the ID is empty, then it is upto the backend to decide whether to
	// throw an error or auto assign an ID.
	// A valid Team object on return WILL have an ID if the backend can
	// auto generate IDs
	//
	// Parameters:
	//  - Team
	SaveTeam(team Team) (r Team, err error)
	// Retrieve teams in a org
	//
	// Parameters:
	//  - Request
	GetTeams(request GetTeamsRequest) (r []*Team, err error)
	// Retrieve a team by either ID or Name and Organization
	//
	// Parameters:
	//  - Team
	GetTeam(team Team) (r Team, err error)
	// Delete a team.
	//
	// Parameters:
	//  - Team
	DeleteTeam(team Team) (err error)
	// Lets a user with the given username join a team (if allowed)
	//
	// Parameters:
	//  - Request
	JoinTeam(request TeamMembershipRequest) (r *User, err error)
	// Tells if a user belongs to a team.
	//
	// Parameters:
	//  - Request
	TeamContains(request TeamMembershipRequest) (r bool, err error)
	// Lets a user leave a team or be kicked out.
	//
	// Parameters:
	//  - Request
	LeaveTeam(request TeamMembershipRequest) (err error)
}

type TeamServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTeamServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *TeamServiceClient {
	return &TeamServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTeamServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *TeamServiceClient {
	return &TeamServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Removes all entries.
func (p *TeamServiceClient) RemoveAllTeams() (err error) {
	if err = p.sendRemoveAllTeams(); err != nil {
		return
	}
	return p.recvRemoveAllTeams()
}

func (p *TeamServiceClient) sendRemoveAllTeams() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("RemoveAllTeams", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RemoveAllTeamsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvRemoveAllTeams() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "RemoveAllTeams failed: out of sequence response")
		return
	}
	result := RemoveAllTeamsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	return
}

// Create or update a team.
// If the ID is empty, then it is upto the backend to decide whether to
// throw an error or auto assign an ID.
// A valid Team object on return WILL have an ID if the backend can
// auto generate IDs
//
// Parameters:
//  - Team
func (p *TeamServiceClient) SaveTeam(team Team) (r Team, err error) {
	if err = p.sendSaveTeam(team); err != nil {
		return
	}
	return p.recvSaveTeam()
}

func (p *TeamServiceClient) sendSaveTeam(team Team) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("SaveTeam", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SaveTeamArgs{
		Team: team,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvSaveTeam() (value Team, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "SaveTeam failed: out of sequence response")
		return
	}
	result := SaveTeamResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Retrieve teams in a org
//
// Parameters:
//  - Request
func (p *TeamServiceClient) GetTeams(request GetTeamsRequest) (r []*Team, err error) {
	if err = p.sendGetTeams(request); err != nil {
		return
	}
	return p.recvGetTeams()
}

func (p *TeamServiceClient) sendGetTeams(request GetTeamsRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTeams", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTeamsArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvGetTeams() (value []*Team, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTeams failed: out of sequence response")
		return
	}
	result := GetTeamsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Retrieve a team by either ID or Name and Organization
//
// Parameters:
//  - Team
func (p *TeamServiceClient) GetTeam(team Team) (r Team, err error) {
	if err = p.sendGetTeam(team); err != nil {
		return
	}
	return p.recvGetTeam()
}

func (p *TeamServiceClient) sendGetTeam(team Team) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTeam", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTeamArgs{
		Team: team,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvGetTeam() (value Team, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTeam failed: out of sequence response")
		return
	}
	result := GetTeamResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Delete a team.
//
// Parameters:
//  - Team
func (p *TeamServiceClient) DeleteTeam(team Team) (err error) {
	if err = p.sendDeleteTeam(team); err != nil {
		return
	}
	return p.recvDeleteTeam()
}

func (p *TeamServiceClient) sendDeleteTeam(team Team) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("DeleteTeam", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteTeamArgs{
		Team: team,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvDeleteTeam() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "DeleteTeam failed: out of sequence response")
		return
	}
	result := DeleteTeamResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	return
}

// Lets a user with the given username join a team (if allowed)
//
// Parameters:
//  - Request
func (p *TeamServiceClient) JoinTeam(request TeamMembershipRequest) (r *User, err error) {
	if err = p.sendJoinTeam(request); err != nil {
		return
	}
	return p.recvJoinTeam()
}

func (p *TeamServiceClient) sendJoinTeam(request TeamMembershipRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("JoinTeam", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := JoinTeamArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvJoinTeam() (value *User, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "JoinTeam failed: out of sequence response")
		return
	}
	result := JoinTeamResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Tells if a user belongs to a team.
//
// Parameters:
//  - Request
func (p *TeamServiceClient) TeamContains(request TeamMembershipRequest) (r bool, err error) {
	if err = p.sendTeamContains(request); err != nil {
		return
	}
	return p.recvTeamContains()
}

func (p *TeamServiceClient) sendTeamContains(request TeamMembershipRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("TeamContains", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TeamContainsArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvTeamContains() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "TeamContains failed: out of sequence response")
		return
	}
	result := TeamContainsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Lets a user leave a team or be kicked out.
//
// Parameters:
//  - Request
func (p *TeamServiceClient) LeaveTeam(request TeamMembershipRequest) (err error) {
	if err = p.sendLeaveTeam(request); err != nil {
		return
	}
	return p.recvLeaveTeam()
}

func (p *TeamServiceClient) sendLeaveTeam(request TeamMembershipRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("LeaveTeam", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LeaveTeamArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *TeamServiceClient) recvLeaveTeam() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "LeaveTeam failed: out of sequence response")
		return
	}
	result := LeaveTeamResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	return
}

type TeamServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      TeamService
}

func (p *TeamServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *TeamServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *TeamServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTeamServiceProcessor(handler TeamService) *TeamServiceProcessor {

	self36 := &TeamServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self36.processorMap["RemoveAllTeams"] = &teamServiceProcessorRemoveAllTeams{handler: handler}
	self36.processorMap["SaveTeam"] = &teamServiceProcessorSaveTeam{handler: handler}
	self36.processorMap["GetTeams"] = &teamServiceProcessorGetTeams{handler: handler}
	self36.processorMap["GetTeam"] = &teamServiceProcessorGetTeam{handler: handler}
	self36.processorMap["DeleteTeam"] = &teamServiceProcessorDeleteTeam{handler: handler}
	self36.processorMap["JoinTeam"] = &teamServiceProcessorJoinTeam{handler: handler}
	self36.processorMap["TeamContains"] = &teamServiceProcessorTeamContains{handler: handler}
	self36.processorMap["LeaveTeam"] = &teamServiceProcessorLeaveTeam{handler: handler}
	return self36
}

func (p *TeamServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x37 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x37.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x37

}

type teamServiceProcessorRemoveAllTeams struct {
	handler TeamService
}

func (p *teamServiceProcessorRemoveAllTeams) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoveAllTeamsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("RemoveAllTeams", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RemoveAllTeamsResult{}
	var err2 error
	if err2 = p.handler.RemoveAllTeams(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing RemoveAllTeams: "+err2.Error())
		oprot.WriteMessageBegin("RemoveAllTeams", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	if err2 = oprot.WriteMessageBegin("RemoveAllTeams", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorSaveTeam struct {
	handler TeamService
}

func (p *teamServiceProcessorSaveTeam) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SaveTeamArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("SaveTeam", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SaveTeamResult{}
	var retval Team
	var err2 error
	if retval, err2 = p.handler.SaveTeam(args.Team); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing SaveTeam: "+err2.Error())
			oprot.WriteMessageBegin("SaveTeam", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("SaveTeam", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorGetTeams struct {
	handler TeamService
}

func (p *teamServiceProcessorGetTeams) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTeamsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTeams", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTeamsResult{}
	var retval []*Team
	var err2 error
	if retval, err2 = p.handler.GetTeams(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTeams: "+err2.Error())
			oprot.WriteMessageBegin("GetTeams", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTeams", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorGetTeam struct {
	handler TeamService
}

func (p *teamServiceProcessorGetTeam) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTeamArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTeam", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTeamResult{}
	var retval Team
	var err2 error
	if retval, err2 = p.handler.GetTeam(args.Team); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTeam: "+err2.Error())
			oprot.WriteMessageBegin("GetTeam", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTeam", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorDeleteTeam struct {
	handler TeamService
}

func (p *teamServiceProcessorDeleteTeam) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteTeamArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("DeleteTeam", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteTeamResult{}
	var err2 error
	if err2 = p.handler.DeleteTeam(args.Team); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DeleteTeam: "+err2.Error())
			oprot.WriteMessageBegin("DeleteTeam", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("DeleteTeam", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorJoinTeam struct {
	handler TeamService
}

func (p *teamServiceProcessorJoinTeam) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := JoinTeamArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("JoinTeam", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := JoinTeamResult{}
	var retval *User
	var err2 error
	if retval, err2 = p.handler.JoinTeam(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing JoinTeam: "+err2.Error())
			oprot.WriteMessageBegin("JoinTeam", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("JoinTeam", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorTeamContains struct {
	handler TeamService
}

func (p *teamServiceProcessorTeamContains) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TeamContainsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("TeamContains", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TeamContainsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.TeamContains(args.Request); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing TeamContains: "+err2.Error())
		oprot.WriteMessageBegin("TeamContains", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("TeamContains", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type teamServiceProcessorLeaveTeam struct {
	handler TeamService
}

func (p *teamServiceProcessorLeaveTeam) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LeaveTeamArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("LeaveTeam", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LeaveTeamResult{}
	var err2 error
	if err2 = p.handler.LeaveTeam(args.Request); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing LeaveTeam: "+err2.Error())
			oprot.WriteMessageBegin("LeaveTeam", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("LeaveTeam", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type RemoveAllTeamsArgs struct {
}

func NewRemoveAllTeamsArgs() *RemoveAllTeamsArgs {
	return &RemoveAllTeamsArgs{}
}

func (p *RemoveAllTeamsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveAllTeamsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("RemoveAllTeams_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveAllTeamsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveAllTeamsArgs(%+v)", *p)
}

type RemoveAllTeamsResult struct {
}

func NewRemoveAllTeamsResult() *RemoveAllTeamsResult {
	return &RemoveAllTeamsResult{}
}

func (p *RemoveAllTeamsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveAllTeamsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("RemoveAllTeams_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveAllTeamsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveAllTeamsResult(%+v)", *p)
}

type SaveTeamArgs struct {
	Team *Team `thrift:"team,1" json:"team"`
}

func NewSaveTeamArgs() *SaveTeamArgs {
	return &SaveTeamArgs{}
}

var SaveTeamArgs_Team_DEFAULT Team

func (p *SaveTeamArgs) GetTeam() Team {
	if !p.IsSetTeam() {
		return SaveTeamArgs_Team_DEFAULT
	}
	return *p.Team
}
func (p *SaveTeamArgs) IsSetTeam() bool {
	return p.Team != nil
}

func (p *SaveTeamArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SaveTeamArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Team = &Team{}
	if err := p.Team.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Team, err)
	}
	return nil
}

func (p *SaveTeamArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SaveTeam_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SaveTeamArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("team", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:team: %s", p, err)
	}
	if err := p.Team.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Team, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:team: %s", p, err)
	}
	return err
}

func (p *SaveTeamArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SaveTeamArgs(%+v)", *p)
}

type SaveTeamResult struct {
	Success *Team  `thrift:"success,0" json:"success"`
	ErrorA1 *Error `thrift:"error,1" json:"error"`
}

func NewSaveTeamResult() *SaveTeamResult {
	return &SaveTeamResult{}
}

var SaveTeamResult_Success_DEFAULT Team

func (p *SaveTeamResult) GetSuccess() Team {
	if !p.IsSetSuccess() {
		return SaveTeamResult_Success_DEFAULT
	}
	return *p.Success
}

var SaveTeamResult_ErrorA1_DEFAULT *Error

func (p *SaveTeamResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return SaveTeamResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *SaveTeamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SaveTeamResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *SaveTeamResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SaveTeamResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Team{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *SaveTeamResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *SaveTeamResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SaveTeam_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SaveTeamResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SaveTeamResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *SaveTeamResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SaveTeamResult(%+v)", *p)
}

type GetTeamsArgs struct {
	Request *GetTeamsRequest `thrift:"request,1" json:"request"`
}

func NewGetTeamsArgs() *GetTeamsArgs {
	return &GetTeamsArgs{}
}

var GetTeamsArgs_Request_DEFAULT GetTeamsRequest

func (p *GetTeamsArgs) GetRequest() GetTeamsRequest {
	if !p.IsSetRequest() {
		return GetTeamsArgs_Request_DEFAULT
	}
	return *p.Request
}
func (p *GetTeamsArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *GetTeamsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTeamsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &GetTeamsRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *GetTeamsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTeams_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTeamsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *GetTeamsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTeamsArgs(%+v)", *p)
}

type GetTeamsResult struct {
	Success []*Team `thrift:"success,0" json:"success"`
	ErrorA1 *Error  `thrift:"error,1" json:"error"`
}

func NewGetTeamsResult() *GetTeamsResult {
	return &GetTeamsResult{}
}

var GetTeamsResult_Success_DEFAULT []*Team

func (p *GetTeamsResult) GetSuccess() []*Team {
	return p.Success
}

var GetTeamsResult_ErrorA1_DEFAULT *Error

func (p *GetTeamsResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return GetTeamsResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *GetTeamsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTeamsResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *GetTeamsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTeamsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Team, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem38 := &Team{}
		if err := _elem38.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem38, err)
		}
		p.Success = append(p.Success, _elem38)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTeamsResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *GetTeamsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTeams_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTeamsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTeamsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *GetTeamsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTeamsResult(%+v)", *p)
}

type GetTeamArgs struct {
	Team *Team `thrift:"team,1" json:"team"`
}

func NewGetTeamArgs() *GetTeamArgs {
	return &GetTeamArgs{}
}

var GetTeamArgs_Team_DEFAULT Team

func (p *GetTeamArgs) GetTeam() Team {
	if !p.IsSetTeam() {
		return GetTeamArgs_Team_DEFAULT
	}
	return *p.Team
}
func (p *GetTeamArgs) IsSetTeam() bool {
	return p.Team != nil
}

func (p *GetTeamArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTeamArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Team = &Team{}
	if err := p.Team.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Team, err)
	}
	return nil
}

func (p *GetTeamArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTeam_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTeamArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("team", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:team: %s", p, err)
	}
	if err := p.Team.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Team, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:team: %s", p, err)
	}
	return err
}

func (p *GetTeamArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTeamArgs(%+v)", *p)
}

type GetTeamResult struct {
	Success *Team  `thrift:"success,0" json:"success"`
	ErrorA1 *Error `thrift:"error,1" json:"error"`
}

func NewGetTeamResult() *GetTeamResult {
	return &GetTeamResult{}
}

var GetTeamResult_Success_DEFAULT Team

func (p *GetTeamResult) GetSuccess() Team {
	if !p.IsSetSuccess() {
		return GetTeamResult_Success_DEFAULT
	}
	return *p.Success
}

var GetTeamResult_ErrorA1_DEFAULT *Error

func (p *GetTeamResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return GetTeamResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *GetTeamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTeamResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *GetTeamResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTeamResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Team{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTeamResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *GetTeamResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTeam_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTeamResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTeamResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *GetTeamResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTeamResult(%+v)", *p)
}

type DeleteTeamArgs struct {
	Team *Team `thrift:"team,1" json:"team"`
}

func NewDeleteTeamArgs() *DeleteTeamArgs {
	return &DeleteTeamArgs{}
}

var DeleteTeamArgs_Team_DEFAULT Team

func (p *DeleteTeamArgs) GetTeam() Team {
	if !p.IsSetTeam() {
		return DeleteTeamArgs_Team_DEFAULT
	}
	return *p.Team
}
func (p *DeleteTeamArgs) IsSetTeam() bool {
	return p.Team != nil
}

func (p *DeleteTeamArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTeamArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Team = &Team{}
	if err := p.Team.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Team, err)
	}
	return nil
}

func (p *DeleteTeamArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteTeam_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTeamArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("team", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:team: %s", p, err)
	}
	if err := p.Team.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Team, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:team: %s", p, err)
	}
	return err
}

func (p *DeleteTeamArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTeamArgs(%+v)", *p)
}

type DeleteTeamResult struct {
	ErrorA1 *Error `thrift:"error,1" json:"error"`
}

func NewDeleteTeamResult() *DeleteTeamResult {
	return &DeleteTeamResult{}
}

var DeleteTeamResult_ErrorA1_DEFAULT *Error

func (p *DeleteTeamResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return DeleteTeamResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *DeleteTeamResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *DeleteTeamResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTeamResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *DeleteTeamResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteTeam_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTeamResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTeamResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTeamResult(%+v)", *p)
}

type JoinTeamArgs struct {
	Request *TeamMembershipRequest `thrift:"request,1" json:"request"`
}

func NewJoinTeamArgs() *JoinTeamArgs {
	return &JoinTeamArgs{}
}

var JoinTeamArgs_Request_DEFAULT TeamMembershipRequest

func (p *JoinTeamArgs) GetRequest() TeamMembershipRequest {
	if !p.IsSetRequest() {
		return JoinTeamArgs_Request_DEFAULT
	}
	return *p.Request
}
func (p *JoinTeamArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *JoinTeamArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *JoinTeamArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &TeamMembershipRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *JoinTeamArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("JoinTeam_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *JoinTeamArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *JoinTeamArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("JoinTeamArgs(%+v)", *p)
}

type JoinTeamResult struct {
	Success *User  `thrift:"success,0" json:"success"`
	ErrorA1 *Error `thrift:"error,1" json:"error"`
}

func NewJoinTeamResult() *JoinTeamResult {
	return &JoinTeamResult{}
}

var JoinTeamResult_Success_DEFAULT *User

func (p *JoinTeamResult) GetSuccess() *User {
	if !p.IsSetSuccess() {
		return JoinTeamResult_Success_DEFAULT
	}
	return p.Success
}

var JoinTeamResult_ErrorA1_DEFAULT *Error

func (p *JoinTeamResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return JoinTeamResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *JoinTeamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *JoinTeamResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *JoinTeamResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *JoinTeamResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &User{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *JoinTeamResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *JoinTeamResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("JoinTeam_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *JoinTeamResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *JoinTeamResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *JoinTeamResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("JoinTeamResult(%+v)", *p)
}

type TeamContainsArgs struct {
	Request *TeamMembershipRequest `thrift:"request,1" json:"request"`
}

func NewTeamContainsArgs() *TeamContainsArgs {
	return &TeamContainsArgs{}
}

var TeamContainsArgs_Request_DEFAULT TeamMembershipRequest

func (p *TeamContainsArgs) GetRequest() TeamMembershipRequest {
	if !p.IsSetRequest() {
		return TeamContainsArgs_Request_DEFAULT
	}
	return *p.Request
}
func (p *TeamContainsArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *TeamContainsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TeamContainsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &TeamMembershipRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *TeamContainsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TeamContains_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TeamContainsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *TeamContainsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TeamContainsArgs(%+v)", *p)
}

type TeamContainsResult struct {
	Success *bool `thrift:"success,0" json:"success"`
}

func NewTeamContainsResult() *TeamContainsResult {
	return &TeamContainsResult{}
}

var TeamContainsResult_Success_DEFAULT bool

func (p *TeamContainsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return TeamContainsResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TeamContainsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TeamContainsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TeamContainsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TeamContainsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TeamContains_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TeamContainsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TeamContainsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TeamContainsResult(%+v)", *p)
}

type LeaveTeamArgs struct {
	Request *TeamMembershipRequest `thrift:"request,1" json:"request"`
}

func NewLeaveTeamArgs() *LeaveTeamArgs {
	return &LeaveTeamArgs{}
}

var LeaveTeamArgs_Request_DEFAULT TeamMembershipRequest

func (p *LeaveTeamArgs) GetRequest() TeamMembershipRequest {
	if !p.IsSetRequest() {
		return LeaveTeamArgs_Request_DEFAULT
	}
	return *p.Request
}
func (p *LeaveTeamArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *LeaveTeamArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveTeamArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Request = &TeamMembershipRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Request, err)
	}
	return nil
}

func (p *LeaveTeamArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("LeaveTeam_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveTeamArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:request: %s", p, err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Request, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:request: %s", p, err)
	}
	return err
}

func (p *LeaveTeamArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveTeamArgs(%+v)", *p)
}

type LeaveTeamResult struct {
	ErrorA1 *Error `thrift:"error,1" json:"error"`
}

func NewLeaveTeamResult() *LeaveTeamResult {
	return &LeaveTeamResult{}
}

var LeaveTeamResult_ErrorA1_DEFAULT *Error

func (p *LeaveTeamResult) GetErrorA1() *Error {
	if !p.IsSetErrorA1() {
		return LeaveTeamResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *LeaveTeamResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *LeaveTeamResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LeaveTeamResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &Error{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *LeaveTeamResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("LeaveTeam_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LeaveTeamResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *LeaveTeamResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LeaveTeamResult(%+v)", *p)
}
